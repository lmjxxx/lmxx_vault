{
	"nodes":[
		{"id":"7ac247125b833758","type":"group","x":-1594,"y":-100,"width":2236,"height":7460,"color":"1","label":"main"},
		{"id":"720b093fca187718","type":"text","text":"# Q. PGROUNDUP 이 아닌 PGROUNDDOWN 으로 정렬하는 이유\n# A. 함수의 동작 방식과 매핑 범위 결정의 정확성 때문\n1. mappes() 는 가상 주소의 시작 지점을 기준으로 매핑을 시작해야 한다. \n\tmappes 는 페이지 경계에서 시작해 가상 주소 범위를 순회하며 페이지 테이블 엔트리 (PTE)를 생성한다.\n\tup 을 사용하면 주소가 실제로 포함된 페이지를 건너뛸 수 있음\n2. PGROUNDDOWN() 은 현재 포한된 페이지의 시작 주소 반환\n\t1. 가상 주소가 속한 페이지의 시작 주소로 내림하기 때문에\n\t2. 주소가 어떤 페이지에 걸쳐 있는지 정확히 매핑할 수 있음\n3. up 을 사용하면 범위가 더 커져 불필요한 페이지가 추가로 매핑될 수 있음","x":2000,"y":3210,"width":880,"height":340},
<<<<<<< Updated upstream
		{"id":"d4d9fd7d4bc1ac83","type":"text","text":"# vm.c : walkpgdir (pgdir, va, alloc)\n\n```c\n// Return the address of the PTE in page table pgdir\n// that corresponds to virtual address va.  If alloc!=0,\n// create any required page table pages.\nstatic pte_t *\nwalkpgdir(pde_t *pgdir, const void *va, int alloc) // pgdir, page 시작주소, alloc =1\n{\n  pde_t *pde;\n  pte_t *pgtab;\n\n// va 상위 10 비트를 이용해 PDE (Page Directory Entry) 선택 pgdir는 1024 개의 엔트리\n// 각 엔트리는 페이지 테이블을 가리킴\n  pde = &pgdir[PDX(va)]; // 가상 주소에서 페이지 디렉터리의 몇번 엔트리인지를 선택하는 거임 -> page directory entry \n  if(*pde & PTE_P){ // PTE_P 페이지 테이블 존재 확인 플래그 \n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde)); // 존재한다면 PTE_ADDR 로 페이지 테이블의 물리 주소를 가져오고 P2V 로 가상주소 변환\n  } else {\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0) // kalloc 으로 새 페이지 할당 \n      return 0;\n    // Make sure all those PTE_P bits are zero.\n    memset(pgtab, 0, PGSIZE); // 초기화 \n    // The permissions here are overly generous, but they can\n    // be further restricted by the permissions in the page table\n    // entries, if necessary.\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U; // Page Directory Entry 플래그 설정 \n    // PTE_P : 페이지 존재 \n    // PTE_W : 읽기/쓰기 가능\n    // PTE_U : 사용자 모드에서도 접근 가능 \n  }\n  return &pgtab[PTX(va)]; // page table 을 반환하는데 가상 주소에 PTX 매크로를 써서 페이지 테이블의 몇번 엔트리 를 반환 \n}\n```","x":2000,"y":3630,"width":1080,"height":760},
		{"id":"19b0f1549257b44e","type":"text","text":"# defs.h : NELEM(x)\n```c\n// number of elements in fixed-size array\n#define NELEM(x) (sizeof(x)/sizeof((x)[0]))\n```","x":1960,"y":2570,"width":460,"height":152},
		{"id":"70754fa19d2b5f1f","type":"text","text":"\n# vm.c : setupkvm(void)\n```c\nmemlayout.h\n#define PHYSTOP 0xE000000\n#define DEVSPACE 0xFE000000         // Other devices are at high addresses\n```\n```c\npde_t*\nsetupkvm(void)\n{\n  pde_t *pgdir;\n  struct kmap *k;\n\n  if((pgdir = (pde_t*)kalloc()) == 0) // kalloc 으로 새로운 페이지 할당.\n    return 0;\n  memset(pgdir, 0, PGSIZE); // 초기화\n  if (P2V(PHYSTOP) > (void*)DEVSPACE) // PHYSTOP : 물리 메모리 상한, DEVSPACE : I/O 장치 공간 시작 \n    panic(\"PHYSTOP too high\");\n  for(k = kmap; k < &kmap[NELEM(kmap)]; k++) // kmap 배열 순회, kmap의 각 항목에 대해 mappings 호출  \n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\n                (uint)k->phys_start, k->perm) < 0) {\n                // k -> virt 가상 메모리 시작 주소\n                // k->phys_end - k->phys_start : 매핑할 메모리 크기\n                // (uint)k->phys_start : 물리 메모리 시작 주소\n                // k->perm : 페이지 권한\n      freevm(pgdir); // 매핑 실패시 할당된 페이잊 테이블 해제\n      return 0; // 0 반환\n    }\n  return pgdir;\n}\n```\n\n# vm.c : mappages(pgdir, va, size, pa, perm)\n```c\n// Create PTEs for virtual addresses starting at va that refer to\n// physical addresses starting at pa. va and size might not\n// be page-aligned.\nstatic int\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm \n// va 가상 메모리 시작 주소, pa, 물리 메모리 시작 주소 \n{\n  char *a, *last;\n  pte_t *pte;\n\n  a = (char*)PGROUNDDOWN((uint)va); // 내림으로 페이지 정렬 페이지 시작주소\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1); // 끝주소 \n  for(;;){ // 반복을 돌면서 \n    if((pte = walkpgdir(pgdir, a, 1)) == 0) // pgdir 와 a를 사용하여 a 에 대한 Page Table Entry 포인터 반환\n      return -1;\n    if(*pte & PTE_P) // 이미 이 virtual address 에 다른 물리 페이지가 매핑된 것\n      panic(\"remap\");\n    *pte = pa | perm | PTE_P; // Page Table Entry 에 물리 메모리 시작 주소, 권한, + PTE_P 플래그 추가\n    if(a == last) // 끝까지 갔으면 종료\n      break;\n    a += PGSIZE; // 페이지 단위로 반복 \n    pa += PGSIZE; // 페이지 단위로 반복 \n  }\n  return 0;\n}\n```","x":948,"y":2570,"width":952,"height":1380},
		{"id":"d2da0014386670b3","type":"text","text":"# kalloc.c : freerange(vstart, vend)\n\n```c\nvoid\nfreerange(void *vstart, void *vend)\n{\n  char *p;\n  p = (char*)PGROUNDUP((uint)vstart); // vstart를 올림 정렬 함.\n  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)\n    kfree(p);\n}\n```\n\n반복문으로 페이지 크기 단위로 kfree 를 사용해서 free 해줌\n\n# kalloc.c : kfree(char *v)\n```c\n//PAGEBREAK: 21\n// Free the page of physical memory pointed at by v,\n// which normally should have been returned by a\n// call to kalloc().  (The exception is when\n// initializing the allocator; see kinit above.)\nvoid\nkfree(char *v)\n{\n  struct run *r;\n\n  // 정렬된 주소인지 확인, 커널이 로드된 메모리 보다 작은지, 물리 주소가 시스템 메모리 상한을 초과하면 해제 불가\n  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP) \n    panic(\"kfree\");\n\n  // Fill with junk to catch dangling refs.\n  // dangling reference 방지를 위해 메모리(페이지) 전체를 0x01 로 덮어쓴다.\n  memset(v, 1, PGSIZE);\n\n  if(kmem.use_lock) // Spinlock , 다른 프로세스가 kmem 에 접근할 수 없도록 락\n    acquire(&kmem.lock); // critical section \n  r = (struct run*)v; \n  r->next = kmem.freelist; // 현재 freelist 의 첫 번째 페이지를 r->next에 연결\n  kmem.freelist = r; // 페이지를 freelist 에 추가한다.\n  if(kmem.use_lock) // Spinlock 해제\n    release(&kmem.lock); // critical section 해제\n}\n```","x":888,"y":1163,"width":940,"height":1011},
		{"id":"bcb9689b43779a38","type":"text","text":"# mmu.h : PDX, PTX\n\n```c\n// A virtual address 'la' has a three-part structure as follows:\n//\n// +--------10------+-------10-------+---------12----------+\n// | Page Directory |   Page Table   | Offset within Page  |\n// |      Index     |      Index     |                     |\n// +----------------+----------------+---------------------+\n//  \\--- PDX(va) --/ \\--- PTX(va) --/\n\n// page directory index\n#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF) \n// PDXSHIFT = 22 가상 주소의 상위 10비트 추출 , 10 비트 마스킹 -> 인덱스 값 \n\n// page table index\n#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)\n// PTXSHIFT = 12 가상 주소의 중간 10비트 추출, 10비트 마스킹 -> 인덱스 값\n\n// Page table/directory entry flags.\n#define PTE_P           0x001   // Present\n#define PTE_W           0x002   // Writeable\n#define PTE_U           0x004   // User\n#define PTE_PS          0x080   // Page Size\n\n\n```\n\npage directory index10\n- 페이지 디렉터리의 엔트리 \n- 1024 개 엔트리로 구성, 각 엔트리는 페이지 테이블을 가리킴\npage table index 10\n- 선택된 페이지 테이블 내에서 어떤 페이지 테이블 엔트리를 선택할지 결정\n- 1024 개 엔트리로 구성 각 엔트리는 4KB 의 물리 메모리 페이지 가리킴\noffset 12\n- 4KB 페이지 내에서 특정 바이트에 접근할 때 사용\n- 0~4095 (0xFFF)범위 ","x":3400,"y":3508,"width":828,"height":882},
		{"id":"3c8ae193606e7ad8","type":"text","text":"# vm.c : struct kmap\n\n```c\n// There is one page table per process, plus one that's used when\n// a CPU is not running any process (kpgdir). The kernel uses the\n// current process's page table during system calls and interrupts;\n// page protection bits prevent user code from using the kernel's\n// mappings.\n//\n// setupkvm() and exec() set up every page table like this:\n//\n//   0..KERNBASE: user memory (text+data+stack+heap), mapped to\n//                phys memory allocated by the kernel\n//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)\n//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)\n//                for the kernel's instructions and r/o data\n//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,\n//                                  rw data + free physical memory\n//   0xfe000000..0: mapped direct (devices such as ioapic)\n//\n// The kernel allocates physical memory for its heap and for user memory\n// between V2P(end) and the end of physical memory (PHYSTOP)\n// (directly addressable from end..P2V(PHYSTOP)).\n\n// This table defines the kernel's mappings, which are present in\n// every process's page table.\nstatic struct kmap {\n  void *virt;\n  uint phys_start;\n  uint phys_end;\n  int perm;\n} kmap[] = {\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\n};\n```\n\n각 프로세스마다 하나의 페이지 테이블을 갖고 있음.\nkpgdir : 커널 전용 페이지 테이블\n- CPU 가 어떤 사용자 프로세스도 실행하지 않을 때 사용\n\n0..KERNBASE : 사용자 프로그램의 메모리 공간 \n- 사용자 코드 (text), data, stack, heap 할당\n- 물리 메모리와 동적 매핑\nKERNBASE..KERNBASE+EXTMEM : I/O 공간\n- 이 영역은 **I/O 메모리 영역 (0..EXTMEM, 확장 메모리)** 과 메핑되어 장치에 직접 접근할 수 있다.\nKERNBASE+EXTMEM..data : 커널의 코드와 읽기 전용 데이터\n- V2P(KERNLINK)..V2P(data) 에 해당하는 물리 메모리 매핑\n- 읽기 보호 적용\ndata..KERNBASE+PHYSTOP : 커널 데이터 및 물리 메모리 풀\n- 커널이 동적으로 할당하는 메모리 (heap) 와 사용 가능한 물리 메모리가 이 공간에 매핑\n0xfe000000..0xffffffff : I/O 장치 공간 (DEVSPACE)\n- I/O 장치 (APIC, IOAPIC) 와 직접 매핑, 메모리 맵 장치에 접근 가능\n","x":3400,"y":1990,"width":857,"height":1220},
=======
>>>>>>> Stashed changes
		{"id":"1af96550f66318e1","type":"text","text":"```c\nstatic struct kmap {\n  void *virt;\n  uint phys_start;\n  uint phys_end;\n  int perm;\n} kmap[] = {\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\n};\n```","x":2121,"y":2790,"width":720,"height":300},
		{"id":"3c8ae193606e7ad8","type":"text","text":"# vm.c : struct kmap\n\n```c\n// There is one page table per process, plus one that's used when\n// a CPU is not running any process (kpgdir). The kernel uses the\n// current process's page table during system calls and interrupts;\n// page protection bits prevent user code from using the kernel's\n// mappings.\n//\n// setupkvm() and exec() set up every page table like this:\n//\n//   0..KERNBASE: user memory (text+data+stack+heap), mapped to\n//                phys memory allocated by the kernel\n//   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)\n//   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)\n//                for the kernel's instructions and r/o data\n//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,\n//                                  rw data + free physical memory\n//   0xfe000000..0: mapped direct (devices such as ioapic)\n//\n// The kernel allocates physical memory for its heap and for user memory\n// between V2P(end) and the end of physical memory (PHYSTOP)\n// (directly addressable from end..P2V(PHYSTOP)).\n\n// This table defines the kernel's mappings, which are present in\n// every process's page table.\nstatic struct kmap {\n  void *virt;\n  uint phys_start;\n  uint phys_end;\n  int perm;\n} kmap[] = {\n { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space\n { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata\n { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, // kern data+memory\n { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, // more devices\n};\n```\n\n각 프로세스마다 하나의 페이지 테이블을 갖고 있음.\nkpgdir : 커널 전용 페이지 테이블\n- CPU 가 어떤 사용자 프로세스도 실행하지 않을 때 사용\n\n0..KERNBASE : 사용자 프로그램의 메모리 공간 \n- 사용자 코드 (text), data, stack, heap 할당\n- 물리 메모리와 동적 매핑\nKERNBASE..KERNBASE+EXTMEM : I/O 공간\n- 이 영역은 **I/O 메모리 영역 (0..EXTMEM, 확장 메모리)** 과 메핑되어 장치에 직접 접근할 수 있다.\nKERNBASE+EXTMEM..data : 커널의 코드와 읽기 전용 데이터\n- V2P(KERNLINK)..V2P(data) 에 해당하는 물리 메모리 매핑\n- 읽기 보호 적용\ndata..KERNBASE+PHYSTOP : 커널 데이터 및 물리 메모리 풀\n- 커널이 동적으로 할당하는 메모리 (heap) 와 사용 가능한 물리 메모리가 이 공간에 매핑\n0xfe000000..0xffffffff : I/O 장치 공간 (DEVSPACE)\n- I/O 장치 (APIC, IOAPIC) 와 직접 매핑, 메모리 맵 장치에 접근 가능\n","x":3400,"y":1990,"width":857,"height":1220},
		{"id":"19b0f1549257b44e","type":"text","text":"# defs.h : NELEM(x)\n```c\n// number of elements in fixed-size array\n#define NELEM(x) (sizeof(x)/sizeof((x)[0]))\n```","x":1960,"y":2570,"width":460,"height":152},
		{"id":"302ce6e45d6903bf","type":"text","text":"### 왜 초기화가 두 단계인가.\nentrypgdir : 부트로더가 커널을 시작할 때 사용하는 초기 페이지 디렉터리 임., 물리 메모리의 일부만 매핑함.\n요 초기 페이지 테이블로는 전체 메모리를 다루기에는 부족해서, 먼저 일부 메모리만 초기화하고 나머지는 두 번째 단계에서 처리하는 것.\n\n","x":108,"y":1394,"width":460,"height":240},
		{"id":"d0882743ca7de9b7","type":"text","text":"# main.c : main()\n```c\n// Bootstrap processor starts running C code here.\n// Allocate a real stack and switch to it, first\n// doing some setup required for memory allocator to work.\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator 0x400000\n  kvmalloc();      // kernel page table\n  mpinit();        // detect other processors\n  lapicinit();     // interrupt controller\n  seginit();       // segment descriptors\n  picinit();       // disable pic\n  ioapicinit();    // another interrupt controller\n  consoleinit();   // console hardware\n  uartinit();      // serial port\n  pinit();         // process table\n  tvinit();        // trap vectors\n  binit();         // buffer cache\n  fileinit();      // file table\n  ideinit();       // disk \n  startothers();   // start other processors\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\n  userinit();      // first user process\n  mpmain();        // finish this processor's setup\n}\n```\n\nkinit1 : 물리 page 를 할당해주는 함수 인 듯 함.\nkvmalloc : 커널 페이지 테이블 할당함수 인듯\nmpinit : 다른 프로세서 감지 라고 적혀있는데 봐야 알 듯\nlapicinit : 인터럽트 관련 인 듯 APIC 초기화\nseginit : segment descriptor 관련\npicinit : Programmable Interrupt Controller 라고 하는데 왜 disable 시켜주지, PIC 비활성화\nioapicinit : I/O APIC 초기화 \nconsoleinit : \nuartinit : serial port 초기화\npinit : 프로세스 테이블 초기화\ntvinit : trap vector 초기화\nbinit : buffer cache 초기화\nfileinit : 파일 테이블 초기화 \nideinit : disk 초기화\nstartothers : other processors 시작 이라는데 일단 몰겠음\nkinit2() : \nuserinit : user Process 초기화\nmpmain : 세팅 종료하고 메인으로 넘어 가는 것인듯.\n","x":-620,"y":-80,"width":793,"height":1120},
		{"id":"afb4acd3401de320","type":"text","text":"## PIC Disable\nProgrammable Interrupt Controller \n를 비활성화 하는 이유는 \nXv6 가 Advanced Programmable Interrupt Controller 를 사용하기 때문\nPIC 는 구형 인터럽트 컨트롤러\nAPIC 는 최신 멀티코어 시스템에서 더 강력함\n\n각 코어가 자체 Local APIC 를 갖고 있고 \n시스템 전체에 I/O APIC 가 존재함\n\n","x":-1120,"y":437,"width":402,"height":360},
		{"id":"7fb21a47be2ec24b","type":"text","text":"```c\n#define P2V(a) ((void *)(((char *) (a)) + KERNBASE))\n```\n물리 주소를 가상 주소로 변환하는 역할을 함.\n물리주소 a 에 KERNBASE 값을 더하여 가상 주소로 변환\nXv6 에서는 KERNBASE 가 0x80000000 으로 정의 \n","x":-6,"y":160,"width":628,"height":200},
		{"id":"a4d5cea80dff25c3","type":"text","text":"우선 real stack 을 할당하고, 그것으로 전환함. \n그러고 memory allocator 가 작동하는데 필요한 것들을 setup 함.","x":-6,"y":0,"width":520,"height":92},
		{"id":"f565a77822cee056","type":"text","text":"# mp.h : structures \n\n```c\nstruct mp {             // floating pointer\n  uchar signature[4];           // \"_MP_\"\n  void *physaddr;               // phys addr of MP config table\n  uchar length;                 // 1\n  uchar specrev;                // [14]\n  uchar checksum;               // all bytes must add up to 0\n  uchar type;                   // MP system config type\n  uchar imcrp;\n  uchar reserved[3];\n};\n\nstruct mpconf {         // configuration table header\n  uchar signature[4];           // \"PCMP\"\n  ushort length;                // total table length\n  uchar version;                // [14]\n  uchar checksum;               // all bytes must add up to 0\n  uchar product[20];            // product id\n  uint *oemtable;               // OEM table pointer\n  ushort oemlength;             // OEM table length\n  ushort entry;                 // entry count\n  uint *lapicaddr;              // address of local APIC\n  ushort xlength;               // extended table length\n  uchar xchecksum;              // extended table checksum\n  uchar reserved;\n};\n\nstruct mpproc {         // processor table entry\n  uchar type;                   // entry type (0)\n  uchar apicid;                 // local APIC id\n  uchar version;                // local APIC verison\n  uchar flags;                  // CPU flags\n    #define MPBOOT 0x02           // This proc is the bootstrap processor.\n  uchar signature[4];           // CPU signature\n  uint feature;                 // feature flags from CPUID instruction\n  uchar reserved[8];\n};\n\nstruct mpioapic {       // I/O APIC table entry\n  uchar type;                   // entry type (2)\n  uchar apicno;                 // I/O APIC id\n  uchar version;                // I/O APIC version\n  uchar flags;                  // I/O APIC flags\n  uint *addr;                  // I/O APIC address\n};\n```\n\nmp :\n- SMP(Symmetric Multiprocessing) 시스템에서 다중 CPU 정보를 포함하는 구조체","x":971,"y":4880,"width":949,"height":1180},
		{"id":"fd49135ac1ce412b","type":"text","text":"# mp.c : mpsearch\n\n```c\n// Search for the MP Floating Pointer Structure, which according to the\n// MP Floating Pointer Structure 를 시스템 메모리 특정 위치에서 탐색\n// spec is in one of the following three locations:\n// 스팩에 따라 MP 구조체가 위치할 수 있는 세 가지 메모리 위치: \n// 1) in the first KB of the EBDA;\n// 1) EBDA (Extended BIOS Data Area) 의 첫 번째 1KB\n// 2) in the last KB of system base memory;\n// 2) 시스템 기본 메모리의 마지막 1KB\n// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.\n// 3) BIOS ROM 메모리 공간 (0xF000 ~ 0xFFFFF)\nstatic struct mp*\nmpsearch(void)\n{\n  uchar *bda;\n  uint p;\n  struct mp *mp;\n\n  bda = (uchar *) P2V(0x400); // bda (BIOS Data Area)\n  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){ // EBDA(세그먼트 단위 (16바이트))로 저장 됨 ) 의 물리 주소 계산 \n    if((mp = mpsearch1(p, 1024))) // EBDA 의 첫 1KB 범위 탐색 \n      return mp;\n  } else {\n    p = ((bda[0x14]<<8)|bda[0x13])*1024;\n    if((mp = mpsearch1(p-1024, 1024)))\n      return mp;\n  }\n  return mpsearch1(0xF0000, 0x10000);\n}\n```","x":2034,"y":6162,"width":706,"height":758},
		{"id":"3111d7371df2b098","type":"text","text":"# CR3 \n\n페이지 디렉터리 기반 주소 변환에 사용되는 컨트롤 레지스터 \n- 32비트 모드에서 CR3는 페이지 디렉터리의 물리 주소를 가리킴\n- 가상 주소 -> 물리 주소 변환 시, CPU는 항상 이 레지스터에 있는 주소에서 페이지 디렉터리를 가져옴\n\n## 동작 과정\n1. 페이지 디렉터리 주소 읽기 (CR3)\n\t- CR3 에 저장된 물리 주소에서 페이지 디렉터리를 찾는다.\n2. 가상 주소 변환 (PDX, PTX, Offset)\n\t- 가상 주소의 상위 10비트 (PDX) 를 사용해 페이지 디렉터리에서 페이지 테이블을 선택한다.\n\t- 중간 10비트(PTX)로 페이지 테이블 엔트리를 찾고, 하위 12비트는 페이지 내 오프셋으로 사용된다.","x":2042,"y":4440,"width":616,"height":520},
		{"id":"d4d9fd7d4bc1ac83","type":"text","text":"# vm.c : walkpgdir (pgdir, va, alloc)\n\n```c\n// Return the address of the PTE in page table pgdir\n// that corresponds to virtual address va.  If alloc!=0,\n// create any required page table pages.\nstatic pte_t *\nwalkpgdir(pde_t *pgdir, const void *va, int alloc) // pgdir, page 시작주소, alloc =1\n{\n  pde_t *pde;\n  pte_t *pgtab;\n\n// va 상위 10 비트를 이용해 PDE (Page Directory Entry) 선택 pgdir는 1024 개의 엔트리\n// 각 엔트리는 페이지 테이블을 가리킴\n  pde = &pgdir[PDX(va)]; // 가상 주소에서 페이지 디렉터리의 몇번 엔트리인지를 선택하는 거임 -> page directory entry \n  if(*pde & PTE_P){ // PTE_P 페이지 테이블 존재 확인 플래그 \n    pgtab = (pte_t*)P2V(PTE_ADDR(*pde)); // 존재한다면 PTE_ADDR 로 페이지 테이블의 물리 주소를 가져오고 P2V 로 가상주소 변환\n  } else {\n    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0) // kalloc 으로 새 페이지 할당 \n      return 0;\n    // Make sure all those PTE_P bits are zero.\n    memset(pgtab, 0, PGSIZE); // 초기화 \n    // The permissions here are overly generous, but they can\n    // be further restricted by the permissions in the page table\n    // entries, if necessary.\n    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U; // Page Directory Entry 플래그 설정 \n    // PTE_P : 페이지 존재 \n    // PTE_W : 읽기/쓰기 가능\n    // PTE_U : 사용자 모드에서도 접근 가능 \n  }\n  return &pgtab[PTX(va)]; // page table 을 반환하는데 가상 주소에 PTX 매크로를 써서 페이지 테이블의 몇번 엔트리 를 반환 \n}\n```","x":2000,"y":3630,"width":1080,"height":760},
		{"id":"bcb9689b43779a38","type":"text","text":"# mmu.h : PDX, PTX\n\n```c\n// A virtual address 'la' has a three-part structure as follows:\n//\n// +--------10------+-------10-------+---------12----------+\n// | Page Directory |   Page Table   | Offset within Page  |\n// |      Index     |      Index     |                     |\n// +----------------+----------------+---------------------+\n//  \\--- PDX(va) --/ \\--- PTX(va) --/\n\n// page directory index\n#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF) \n// PDXSHIFT = 22 가상 주소의 상위 10비트 추출 , 10 비트 마스킹 -> 인덱스 값 \n\n// page table index\n#define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)\n// PTXSHIFT = 12 가상 주소의 중간 10비트 추출, 10비트 마스킹 -> 인덱스 값\n\n// Page table/directory entry flags.\n#define PTE_P           0x001   // Present\n#define PTE_W           0x002   // Writeable\n#define PTE_U           0x004   // User\n#define PTE_PS          0x080   // Page Size\n\n\n```\n\npage directory index10\n- 페이지 디렉터리의 엔트리 \n- 1024 개 엔트리로 구성, 각 엔트리는 페이지 테이블을 가리킴\npage table index 10\n- 선택된 페이지 테이블 내에서 어떤 페이지 테이블 엔트리를 선택할지 결정\n- 1024 개 엔트리로 구성 각 엔트리는 4KB 의 물리 메모리 페이지 가리킴\noffset 12\n- 4KB 페이지 내에서 특정 바이트에 접근할 때 사용\n- 0~4095 (0xFFF)범위 ","x":3400,"y":3508,"width":828,"height":882},
		{"id":"05aba1dc6b726a8c","type":"text","text":"v : 해제할 물리 메모리 페이지의 포인터\nkalloc() 함수로 할당된 메모리 페이지를 해제함.\n정상적인 상황에서는 v 는 반드시 kalloc() 이 반환한 페이지여야 함.\n초기 memory allocator 초기화 (kinit())에서는 예외적으로 kalloc() 없어도 해제가 가능하다\n\n# Q. 코드 상에서 v가 kalloc 이 반환한 페이지 인지 검사하는게 명시적으로 없는데.\n# A. 유효성 검사, 메모리 관리 방식(freelist)이 결합되어 간접적으로 보장됨\n```c\n  // 정렬된 주소인지 확인, 커널이 로드된 메모리 보다 작은지, 물리 주소가 시스템 메모리 상한을 초과하면 해제 불가\n  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP) \n    panic(\"kfree\");\n```\n일단 여기서 유효성 검사를 함.\nkalloc() 검사 코드가 없는 이유는 ,\n우선 freelist 로 관리하기 때문임. kalloc 은 메모리 풀에서 페이지를 할당하고, kfree()는 해제된 페이지를 다시 freelist 에 추가하는데 freelist 에 없는 페이지는 할당되지 않기 때문에, kalloc() 이 반환하지 않은 페이지를 실수로 해제할 가능성이 거의 없음\n또, 초기화 과정에서 페이지를 직접 kfree 로 메모리 풀에 등록하기 때문에 명시적 kalloc 검사가 있으면 초기화 과정에서 문제가 발생할 수 있음 .  이게 주석에 있는 예외 부분\n\n# Q. 왜 LIFO 방식으로 Freelist를 관리하나.\n# A. 최근에 해제된 페이지가 다시 할당될 가능성이 크기 때문.\n","x":1960,"y":1394,"width":922,"height":780},
		{"id":"c53581449d2a4623","type":"text","text":"# mmu.h \n```c\n#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))\n#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))\n```\n\n메모리 주소 정렬을 위해 사용 \nPGSIZE = 4096\n\nPGROUNDUP(sz) - 주어진 주소를 페이지 크기 (PGSIZE) 단위로 올림\n메모리 크기를 페이지 단위로 할당할 때, 남는 부분을 버리지 않고 다음 페이지로 올림\n\n(sz + PGSIZE - 1) & ~(PGSIZE -1) \n- sz + PGSIZE - 1 : 올림을 위해 PGSIZE -1 (하위 12비트를 1로 채움) 을 더함\n- & ~(PGSIZE -1) : 하위 비트를 잘라내어 PGSIZE 배수로 정렬\n\t- ~(PGSIZE -1) = 0xFFFFF000 하위 2 비트가 0인 마스크\n\n\nPGROUNDDOWN(a) - 주어진 주소를 페이지 크기(PGSIZE) 단위로 내림\n주소를 가장 가까운 이전 페이지 경계로 정렬\na & ~(PGSIZE -1)\n- & ~(PGSIZE -1) : 하위 비트를 잘라서 이전 페이지 경계로 내림","x":2785,"y":523,"width":736,"height":640},
		{"id":"565384e1ff779833","type":"text","text":"# Q. 원한는 크기보다 적게, 크게 할당되는게 아닌가? \n\n# A. 주소를 정렬하기 위한 작업일 뿐 할당 크기와 직접적으로 관련되지 않는다.\nPGROUNDDOWN 은 주소를 이전 페이지 경계로 내림해서 페이지 경계에서 시작하는 주소를 반환함. \n이건 메모리 할당 자체와는 무관함. \n주소 정렬을 위한 보조 도구인 것임","x":3539,"y":869,"width":826,"height":285},
<<<<<<< Updated upstream
		{"id":"05aba1dc6b726a8c","type":"text","text":"v : 해제할 물리 메모리 페이지의 포인터\nkalloc() 함수로 할당된 메모리 페이지를 해제함.\n정상적인 상황에서는 v 는 반드시 kalloc() 이 반환한 페이지여야 함.\n초기 memory allocator 초기화 (kinit())에서는 예외적으로 kalloc() 없어도 해제가 가능하다\n\n# Q. 코드 상에서 v가 kalloc 이 반환한 페이지 인지 검사하는게 명시적으로 없는데.\n# A. 유효성 검사, 메모리 관리 방식(freelist)이 결합되어 간접적으로 보장됨\n```c\n  // 정렬된 주소인지 확인, 커널이 로드된 메모리 보다 작은지, 물리 주소가 시스템 메모리 상한을 초과하면 해제 불가\n  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP) \n    panic(\"kfree\");\n```\n일단 여기서 유효성 검사를 함.\nkalloc() 검사 코드가 없는 이유는 ,\n우선 freelist 로 관리하기 때문임. kalloc 은 메모리 풀에서 페이지를 할당하고, kfree()는 해제된 페이지를 다시 freelist 에 추가하는데 freelist 에 없는 페이지는 할당되지 않기 때문에, kalloc() 이 반환하지 않은 페이지를 실수로 해제할 가능성이 거의 없음\n또, 초기화 과정에서 페이지를 직접 kfree 로 메모리 풀에 등록하기 때문에 명시적 kalloc 검사가 있으면 초기화 과정에서 문제가 발생할 수 있음 .  이게 주석에 있는 예외 부분\n\n# Q. 왜 LIFO 방식으로 Freelist를 관리하나.\n# A. 최근에 해제된 페이지가 다시 할당될 가능성이 크기 때문.\n","x":1960,"y":1394,"width":922,"height":780},
=======
		{"id":"8904de52238c6c96","type":"text","text":"# mp.c :  mpconfig\n\n```c\n// Search for an MP configuration table.  For now,\n// don't accept the default configurations (physaddr == 0).\n// Check for correct signature, calculate the checksum and,\n// if correct, check the version.\n// To do: check extended table checksum.\nstatic struct mpconf*\nmpconfig(struct mp **pmp) // \n{\n  struct mpconf *conf;\n  struct mp *mp;\n\n  if((mp = mpsearch()) == 0 || mp->physaddr == 0) // mpsearch 구조체 탐색\n    return 0;\n  conf = (struct mpconf*) P2V((uint) mp->physaddr); // mp 구조체에 mpconf \n  if(memcmp(conf, \"PCMP\", 4) != 0) // PCMP 시그니처 있는지 확인\n    return 0;\n  if(conf->version != 1 && conf->version != 4) // 버전 확인\n    return 0; \n  if(sum((uchar*)conf, conf->length) != 0) // \n    return 0;\n  *pmp = mp;\n  return conf;\n}\n```","x":971,"y":6240,"width":789,"height":620},
		{"id":"30338f74372e9483","type":"text","text":"# mp.c : mpinit\n```c\n\nvoid\nmpinit(void)\n{\n  uchar *p, *e;\n  int ismp;\n  struct mp *mp; // multi processor 시스템의 구성 정보  signature : \"_MP_\"\n  struct mpconf *conf; // configuration table header signature : \"PCMP\"\n  struct mpproc *proc; // processor table entry \n  struct mpioapic *ioapic; // I/O APIC table entry \n\n  if((conf = mpconfig(&mp)) == 0)\n    panic(\"Expect to run on an SMP\");\n  ismp = 1;\n  lapic = (uint*)conf->lapicaddr; // local APIC address\n  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){\n    switch(*p){\n    case MPPROC:\n      proc = (struct mpproc*)p;\n      if(ncpu < NCPU) {\n        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu\n        ncpu++;\n      }\n      p += sizeof(struct mpproc);\n      continue;\n    case MPIOAPIC:\n      ioapic = (struct mpioapic*)p;\n      ioapicid = ioapic->apicno;\n      p += sizeof(struct mpioapic);\n      continue;\n    case MPBUS:\n    case MPIOINTR:\n    case MPLINTR:\n      p += 8;\n      continue;\n    default:\n      ismp = 0;\n      break;\n    }\n  }\n  if(!ismp)\n    panic(\"Didn't find a suitable machine\");\n\n  if(mp->imcrp){\n    // Bochs doesn't support IMCR, so this doesn't run on Bochs.\n    // But it would on real hardware.\n    outb(0x22, 0x70);   // Select IMCR\n    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.\n  }\n}\n```","x":-560,"y":4960,"width":760,"height":1200},
		{"id":"e7bd727ee95759a6","type":"text","text":"#  MP : MultiProcessor","x":-40,"y":4960,"width":440,"height":160},
		{"id":"be13f40570ef3608","type":"text","text":"# vm.c : switchkvm\n```c\nvoid\nswitchkvm(void)\n{\n  lcr3(V2P(kpgdir));   // switch to the kernel page table\n}\n```\n커널의 페이지 테이블로 전환하기 위해 사용 \nCR3 레지스터에는 물리 주소가 저장되어야 하므로 V2P 로 물리 주소로 변환해서 넣어주는 것\n\n# x86.h : lcr3\n```c\nstatic inline void\nlcr3(uint val)\n{\n  asm volatile(\"movl %0,%%cr3\" : : \"r\" (val));\n}\n```\ncr3 레지스터에 커널 페이지 디렉터리 주소를 설정한다.\n```asm\nmovl val, %cr3 \n```","x":990,"y":4060,"width":868,"height":660},
		{"id":"70754fa19d2b5f1f","type":"text","text":"\n# vm.c : setupkvm(void)\n```c\nmemlayout.h\n#define PHYSTOP 0xE000000\n#define DEVSPACE 0xFE000000         // Other devices are at high addresses\n```\n```c\npde_t*\nsetupkvm(void)\n{\n  pde_t *pgdir;\n  struct kmap *k;\n\n  if((pgdir = (pde_t*)kalloc()) == 0) // kalloc 으로 새로운 페이지 할당.\n    return 0;\n  memset(pgdir, 0, PGSIZE); // 초기화\n  if (P2V(PHYSTOP) > (void*)DEVSPACE) // PHYSTOP : 물리 메모리 상한, DEVSPACE : I/O 장치 공간 시작 \n    panic(\"PHYSTOP too high\");\n  for(k = kmap; k < &kmap[NELEM(kmap)]; k++) // kmap 배열 순회, kmap의 각 항목에 대해 mappings 호출  \n    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,\n                (uint)k->phys_start, k->perm) < 0) {\n                // k -> virt 가상 메모리 시작 주소\n                // k->phys_end - k->phys_start : 매핑할 메모리 크기\n                // (uint)k->phys_start : 물리 메모리 시작 주소\n                // k->perm : 페이지 권한\n      freevm(pgdir); // 매핑 실패시 할당된 페이잊 테이블 해제\n      return 0; // 0 반환\n    }\n  return pgdir;\n}\n```\n\n# vm.c : mappages(pgdir, va, size, pa, perm)\n```c\n// Create PTEs for virtual addresses starting at va that refer to\n// physical addresses starting at pa. va and size might not\n// be page-aligned.\nstatic int\nmappages(pde_t *pgdir, void *va, uint size, uint pa, int perm \n// va 가상 메모리 시작 주소, pa, 물리 메모리 시작 주소 \n{\n  char *a, *last;\n  pte_t *pte;\n\n  a = (char*)PGROUNDDOWN((uint)va); // 내림으로 페이지 정렬 페이지 시작주소\n  last = (char*)PGROUNDDOWN(((uint)va) + size - 1); // 끝주소 \n  for(;;){ // 반복을 돌면서 \n    if((pte = walkpgdir(pgdir, a, 1)) == 0) // pgdir 와 a를 사용하여 a 에 대한 Page Table Entry 포인터 반환\n      return -1;\n    if(*pte & PTE_P) // 이미 이 virtual address 에 다른 물리 페이지가 매핑된 것\n      panic(\"remap\");\n    *pte = pa | perm | PTE_P; // Page Table Entry 에 물리 메모리 시작 주소, 권한, + PTE_P 플래그 추가\n    if(a == last) // 끝까지 갔으면 종료\n      break;\n    a += PGSIZE; // 페이지 단위로 반복 \n    pa += PGSIZE; // 페이지 단위로 반복 \n  }\n  return 0;\n}\n```","x":948,"y":2570,"width":952,"height":1380},
		{"id":"18f8d1a63e3e7dc9","type":"text","text":"kernel vitual memory \n커널이 사용할 페이지 테이블을 구성\n\n","x":173,"y":3180,"width":449,"height":168},
		{"id":"d2da0014386670b3","type":"text","text":"# kalloc.c : freerange(vstart, vend)\n\n```c\nvoid\nfreerange(void *vstart, void *vend)\n{\n  char *p;\n  p = (char*)PGROUNDUP((uint)vstart); // vstart를 올림 정렬 함.\n  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)\n    kfree(p);\n}\n```\n\n반복문으로 페이지 크기 단위로 kfree 를 사용해서 free 해줌\n\n# kalloc.c : kfree(char *v)\n```c\n//PAGEBREAK: 21\n// Free the page of physical memory pointed at by v,\n// which normally should have been returned by a\n// call to kalloc().  (The exception is when\n// initializing the allocator; see kinit above.)\nvoid\nkfree(char *v)\n{\n  struct run *r;\n\n  // 정렬된 주소인지 확인, 커널이 로드된 메모리 보다 작은지, 물리 주소가 시스템 메모리 상한을 초과하면 해제 불가\n  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP) \n    panic(\"kfree\");\n\n  // Fill with junk to catch dangling refs.\n  // dangling reference 방지를 위해 메모리(페이지) 전체를 0x01 로 덮어쓴다.\n  memset(v, 1, PGSIZE);\n\n  if(kmem.use_lock) // Spinlock , 다른 프로세스가 kmem 에 접근할 수 없도록 락\n    acquire(&kmem.lock); // critical section \n  r = (struct run*)v; \n  r->next = kmem.freelist; // 현재 freelist 의 첫 번째 페이지를 r->next에 연결\n  kmem.freelist = r; // 페이지를 freelist 에 추가한다.\n  if(kmem.use_lock) // Spinlock 해제\n    release(&kmem.lock); // critical section 해제\n}\n```","x":888,"y":1163,"width":940,"height":1011},
		{"id":"f8429fd3cd8338f8","type":"text","text":"# Spinlock.h\n\n```c\n// Mutual exclusion lock.\nstruct spinlock {\n  uint locked;       // 락이 현재 점유중인지 여부 (1이면 락 걸려있는 것)\n\n  // For debugging:\n  char *name;        // 락 이름 (디버깅용)\n  struct cpu *cpu;   // 현재 이 락을 소유하고 있는 CPU 정보\n  uint pcs[10];      // 락을 소유한 시점의 호출 스택 정보 (최대 10개)\n};\n```","x":-1574,"y":1480,"width":700,"height":377},
>>>>>>> Stashed changes
		{"id":"d3817c8333c05821","type":"text","text":"# spinlock.h : initlock(&kmem.lock, \"kmem\")\n\n```c\n// Mutual exclusion lock.\nstruct spinlock {\n  uint locked;       // 락이 현재 점유중인지 여부 (1이면 락 걸려있는 것)\n\n  // For debugging:\n  char *name;        // 락 이름 (디버깅용)\n  struct cpu *cpu;   // 현재 이 락을 소유하고 있는 CPU 정보\n  uint pcs[10];      // 락을 소유한 시점의 호출 스택 정보 (최대 10개)\n};\n```\n\n```c\nvoid\ninitlock(struct spinlock *lk, char *name)\n{\n  lk->name = name;  // 락 이름 (\"kmem\")\n  lk->locked = 0; \n  lk->cpu = 0; \n}\n```","x":888,"y":449,"width":720,"height":510},
		{"id":"4dab7798fcfcd0b1","type":"text","text":"# fasdfdsfasfad\n","x":819,"y":-104,"width":539,"height":364},
		{"id":"93d2c5020b089af9","type":"text","text":"# vm.c : kvmalloc(void)\n\n```c\n// Allocate one page table for the machine for the kernel address\n// space for scheduler processes.\nvoid\nkvmalloc(void)\n{\n  kpgdir = setupkvm(); // Kernel page direcutory 할다\n  switchkvm(); // kernel의 페이지 테이블로 전환\n}\n\n```\n\n","x":-560,"y":3180,"width":678,"height":400},
		{"id":"80b04e657081613f","type":"text","text":"# kalloc.c : kinit1(end, P2V(4\\*1024\\*1024))\n\n```c\nvoid freerange(void *vstart, void *vend);\n\nstruct run {\n  struct run *next;\n};\n\nstruct {\n  struct spinlock lock; // 여러 프로세스가 동시에 페이지 할당/해제를 수행하지 않도록\n  int use_lock; // kmem 에서 락을 사용할지 여부 \n  struct run *freelist; // 사용 가능한 메모리 페이지의 연결 리스트\n} kmem; // 물리 페이지 할당 관리 구조체 \n\n// Initialization happens in two phases.\n// 1. main() calls kinit1() while still using entrypgdir to place just\n// the pages mapped by entrypgdir on free list.\n// 2. main() calls kinit2() with the rest of the physical pages\n// after installing a full page table that maps them on all cores.\nvoid\nkinit1(void *vstart, void *vend) // end = 0x80400000\n{\n  initlock(&kmem.lock, \"kmem\"); // spinlock 초기화, lock 이름을 kmem 으로 초기화\n  kmem.use_lock = 0; // kinit1 에서는 락을 사용하지 않음\n  freerange(vstart, vend); //\n}\n```\n\n","x":-587,"y":1560,"width":727,"height":680},
		{"id":"cd6c2f4b3e87c23f","type":"text","text":"## Spinlock \n동기화 메커니즘 \nmutual exclusion 을 보장하는 lock 이다. \nspin 은 lock 을 획득할 때까지 계속 루프 (Busy-Waiting) 을 하기 때문에 붙은 이름임\n\n**Busy-Wait** : \n락이 해제될 때까지 CPU 가 루프를 돌며 (lock을 확인하며) 기다린다.\n-> CPU 자원을 소모하지만, 컨텍스트 스위치가 없기 대문에 짧은 시간 내에 락이 해제될 경우 빠를 수 있음\n**Critical Section** :\nMutex 같은 게 더 적합함.","x":-1264,"y":1900,"width":546,"height":380},
<<<<<<< Updated upstream
		{"id":"f8429fd3cd8338f8","type":"text","text":"# Spinlock.h\n\n```c\n// Mutual exclusion lock.\nstruct spinlock {\n  uint locked;       // 락이 현재 점유중인지 여부 (1이면 락 걸려있는 것)\n\n  // For debugging:\n  char *name;        // 락 이름 (디버깅용)\n  struct cpu *cpu;   // 현재 이 락을 소유하고 있는 CPU 정보\n  uint pcs[10];      // 락을 소유한 시점의 호출 스택 정보 (최대 10개)\n};\n```","x":-1574,"y":1480,"width":700,"height":377},
		{"id":"d0882743ca7de9b7","type":"text","text":"# main.c : main()\n```c\n// Bootstrap processor starts running C code here.\n// Allocate a real stack and switch to it, first\n// doing some setup required for memory allocator to work.\nint\nmain(void)\n{\n  kinit1(end, P2V(4*1024*1024)); // phys page allocator 0x400000\n  kvmalloc();      // kernel page table\n  mpinit();        // detect other processors\n  lapicinit();     // interrupt controller\n  seginit();       // segment descriptors\n  picinit();       // disable pic\n  ioapicinit();    // another interrupt controller\n  consoleinit();   // console hardware\n  uartinit();      // serial port\n  pinit();         // process table\n  tvinit();        // trap vectors\n  binit();         // buffer cache\n  fileinit();      // file table\n  ideinit();       // disk \n  startothers();   // start other processors\n  kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()\n  userinit();      // first user process\n  mpmain();        // finish this processor's setup\n}\n```\n\nkinit1 : 물리 page 를 할당해주는 함수 인 듯 함.\nkvmalloc : 커널 페이지 테이블 할당함수 인듯\nmpinit : 다른 프로세서 감지 라고 적혀있는데 봐야 알 듯\nlapicinit : 인터럽트 관련 인 듯 APIC 초기화\nseginit : segment descriptor 관련\npicinit : Programmable Interrupt Controller 라고 하는데 왜 disable 시켜주지, PIC 비활성화\nioapicinit : I/O APIC 초기화 \nconsoleinit : \nuartinit : serial port 초기화\npinit : 프로세스 테이블 초기화\ntvinit : trap vector 초기화\nbinit : buffer cache 초기화\nfileinit : 파일 테이블 초기화 \nideinit : disk 초기화\nstartothers : other processors 시작 이라는데 일단 몰겠음\nkinit2() : \nuserinit : user Process 초기화\nmpmain : 세팅 종료하고 메인으로 넘어 가는 것인듯.\n","x":-620,"y":-80,"width":793,"height":1120},
		{"id":"afb4acd3401de320","type":"text","text":"## PIC Disable\nProgrammable Interrupt Controller \n를 비활성화 하는 이유는 \nXv6 가 Advanced Programmable Interrupt Controller 를 사용하기 때문\nPIC 는 구형 인터럽트 컨트롤러\nAPIC 는 최신 멀티코어 시스템에서 더 강력함\n\n각 코어가 자체 Local APIC 를 갖고 있고 \n시스템 전체에 I/O APIC 가 존재함\n\n","x":-1120,"y":437,"width":402,"height":360},
		{"id":"a4d5cea80dff25c3","type":"text","text":"우선 real stack 을 할당하고, 그것으로 전환함. \n그러고 memory allocator 가 작동하는데 필요한 것들을 setup 함.","x":-6,"y":0,"width":520,"height":92},
		{"id":"3111d7371df2b098","type":"text","text":"# CR3 \n\n페이지 디렉터리 기반 주소 변환에 사용되는 컨트롤 레지스터 \n- 32비트 모드에서 CR3는 페이지 디렉터리의 물리 주소를 가리킴\n- 가상 주소 -> 물리 주소 변환 시, CPU는 항상 이 레지스터에 있는 주소에서 페이지 디렉터리를 가져옴\n\n## 동작 과정\n1. 페이지 디렉터리 주소 읽기 (CR3)\n\t- CR3 에 저장된 물리 주소에서 페이지 디렉터리를 찾는다.\n2. 가상 주소 변환 (PDX, PTX, Offset)\n\t- 가상 주소의 상위 10비트 (PDX) 를 사용해 페이지 디렉터리에서 페이지 테이블을 선택한다.\n\t- 중간 10비트(PTX)로 페이지 테이블 엔트리를 찾고, 하위 12비트는 페이지 내 오프셋으로 사용된다.","x":2042,"y":4440,"width":616,"height":520},
		{"id":"30338f74372e9483","type":"text","text":"# mp.c : mpinit\n```c\n\nvoid\nmpinit(void)\n{\n  uchar *p, *e;\n  int ismp;\n  struct mp *mp; // multi processor 시스템의 구성 정보  signature : \"_MP_\"\n  struct mpconf *conf; // configuration table header signature : \"PCMP\"\n  struct mpproc *proc; // processor table entry \n  struct mpioapic *ioapic; // I/O APIC table entry \n\n  if((conf = mpconfig(&mp)) == 0)\n    panic(\"Expect to run on an SMP\");\n  ismp = 1;\n  lapic = (uint*)conf->lapicaddr;\n  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){\n    switch(*p){\n    case MPPROC:\n      proc = (struct mpproc*)p;\n      if(ncpu < NCPU) {\n        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu\n        ncpu++;\n      }\n      p += sizeof(struct mpproc);\n      continue;\n    case MPIOAPIC:\n      ioapic = (struct mpioapic*)p;\n      ioapicid = ioapic->apicno;\n      p += sizeof(struct mpioapic);\n      continue;\n    case MPBUS:\n    case MPIOINTR:\n    case MPLINTR:\n      p += 8;\n      continue;\n    default:\n      ismp = 0;\n      break;\n    }\n  }\n  if(!ismp)\n    panic(\"Didn't find a suitable machine\");\n\n  if(mp->imcrp){\n    // Bochs doesn't support IMCR, so this doesn't run on Bochs.\n    // But it would on real hardware.\n    outb(0x22, 0x70);   // Select IMCR\n    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.\n  }\n}\n```","x":-560,"y":4960,"width":689,"height":1200},
		{"id":"e7bd727ee95759a6","type":"text","text":"#  MP : MultiProcessor","x":-40,"y":4960,"width":440,"height":160},
		{"id":"be13f40570ef3608","type":"text","text":"# vm.c : switchkvm\n```c\nvoid\nswitchkvm(void)\n{\n  lcr3(V2P(kpgdir));   // switch to the kernel page table\n}\n```\n커널의 페이지 테이블로 전환하기 위해 사용 \nCR3 레지스터에는 물리 주소가 저장되어야 하므로 V2P 로 물리 주소로 변환해서 넣어주는 것\n\n# x86.h : lcr3\n```c\nstatic inline void\nlcr3(uint val)\n{\n  asm volatile(\"movl %0,%%cr3\" : : \"r\" (val));\n}\n```\ncr3 레지스터에 커널 페이지 디렉터리 주소를 설정한다.\n```asm\nmovl val, %cr3 \n```","x":990,"y":4060,"width":868,"height":660},
		{"id":"f565a77822cee056","type":"text","text":"# mp.h : structures \n\n```c\nstruct mp {             // floating pointer\n  uchar signature[4];           // \"_MP_\"\n  void *physaddr;               // phys addr of MP config table\n  uchar length;                 // 1\n  uchar specrev;                // [14]\n  uchar checksum;               // all bytes must add up to 0\n  uchar type;                   // MP system config type\n  uchar imcrp;\n  uchar reserved[3];\n};\n\nstruct mpconf {         // configuration table header\n  uchar signature[4];           // \"PCMP\"\n  ushort length;                // total table length\n  uchar version;                // [14]\n  uchar checksum;               // all bytes must add up to 0\n  uchar product[20];            // product id\n  uint *oemtable;               // OEM table pointer\n  ushort oemlength;             // OEM table length\n  ushort entry;                 // entry count\n  uint *lapicaddr;              // address of local APIC\n  ushort xlength;               // extended table length\n  uchar xchecksum;              // extended table checksum\n  uchar reserved;\n};\n\nstruct mpproc {         // processor table entry\n  uchar type;                   // entry type (0)\n  uchar apicid;                 // local APIC id\n  uchar version;                // local APIC verison\n  uchar flags;                  // CPU flags\n    #define MPBOOT 0x02           // This proc is the bootstrap processor.\n  uchar signature[4];           // CPU signature\n  uint feature;                 // feature flags from CPUID instruction\n  uchar reserved[8];\n};\n\nstruct mpioapic {       // I/O APIC table entry\n  uchar type;                   // entry type (2)\n  uchar apicno;                 // I/O APIC id\n  uchar version;                // I/O APIC version\n  uchar flags;                  // I/O APIC flags\n  uint *addr;                  // I/O APIC address\n};\n```\n\nmp :\n- SMP(Symmetric Multiprocessing) 시스템에서 다중 CPU 정보를 포함하는 구조체","x":971,"y":4880,"width":949,"height":1180},
		{"id":"8904de52238c6c96","type":"text","text":"# mp.c :  mpconfig\n\n```c\n// Search for an MP configuration table.  For now,\n// don't accept the default configurations (physaddr == 0).\n// Check for correct signature, calculate the checksum and,\n// if correct, check the version.\n// To do: check extended table checksum.\nstatic struct mpconf*\nmpconfig(struct mp **pmp) // \n{\n  struct mpconf *conf;\n  struct mp *mp;\n\n  if((mp = mpsearch()) == 0 || mp->physaddr == 0) // mpsearch 구조체 탐색\n    return 0;\n  conf = (struct mpconf*) P2V((uint) mp->physaddr);\n  if(memcmp(conf, \"PCMP\", 4) != 0)\n    return 0;\n  if(conf->version != 1 && conf->version != 4)\n    return 0;\n  if(sum((uchar*)conf, conf->length) != 0)\n    return 0;\n  *pmp = mp;\n  return conf;\n}\n```","x":971,"y":6240,"width":789,"height":620},
		{"id":"fd49135ac1ce412b","type":"text","text":"# mp.c : mpsearch\n\n```c\n// Search for the MP Floating Pointer Structure, which according to the\n// MP Floating Pointer Structure 를 시스템 메모리 특정 위치에서 탐색\n// spec is in one of the following three locations:\n// 스팩에 따라 MP 구조체가 위치할 수 있는 세 가지 메모리 위치: \n// 1) in the first KB of the EBDA;\n// 1) EBDA (Extended BIOS Data Area) 의 첫 번째 1KB\n// 2) in the last KB of system base memory;\n// 2) 시스템 기본 메모리의 마지막 1KB\n// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.\n// 3) BIOS ROM 메모리 공간 (0xF000 ~ 0xFFFFF)\nstatic struct mp*\nmpsearch(void)\n{\n  uchar *bda;\n  uint p;\n  struct mp *mp;\n\n  bda = (uchar *) P2V(0x400); // bda (BIOS Data Area)\n  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){ // EBDA(세그먼트 단위 (16바이트))로 저장 됨 ) 의 물리 주소 계산 \n    if((mp = mpsearch1(p, 1024))) // EBDA 의 첫 1KB 범위 탐색 \n      return mp;\n  } else {\n    p = ((bda[0x14]<<8)|bda[0x13])*1024;\n    if((mp = mpsearch1(p-1024, 1024)))\n      return mp;\n  }\n  return mpsearch1(0xF0000, 0x10000);\n}\n```","x":2034,"y":6162,"width":706,"height":798},
		{"id":"a9482e7dbac2ece9","type":"text","text":"# mp.c : mpsearch1\n\n```c\n// Look for an MP structure in the len bytes at addr.\n// 주소에서 len 으로 들엉오는 범위 내에 MP structure 가 있는지 탐색\nstatic struct mp*\nmpsearch1(uint a, int len)\n{\n  uchar *e, *p, *addr;\n\n  addr = P2V(a); // \n  e = addr+len;\n  for(p = addr; p < e; p += sizeof(struct mp))\n    if(memcmp(p, \"_MP_\", 4) == 0 && sum(p, sizeof(struct mp)) == 0)\n      return (struct mp*)p;\n  return 0;\n}\n\n```","x":2992,"y":6157,"width":688,"height":463},
		{"id":"81730b7b1e2e7179","type":"text","text":"# string.c : memcmp\n```c\nint\nmemcmp(const void *v1, const void *v2, uint n)\n{\n  const uchar *s1, *s2;\n\n  s1 = v1;\n  s2 = v2;\n  while(n-- > 0){\n    if(*s1 != *s2)\n      return *s1 - *s2;\n    s1++, s2++;\n  }\n\n  return 0;\n}\n```","x":3820,"y":5860,"width":520,"height":483}
=======
		{"id":"a9482e7dbac2ece9","type":"text","text":"# mp.c : mpsearch1\n\n```c\n// Look for an MP structure in the len bytes at addr.\n// 주소에서 len 으로 들엉오는 범위 내에 MP structure 가 있는지 탐색\nstatic struct mp*\nmpsearch1(uint a, int len)\n{\n  uchar *e, *p, *addr;\n\n  addr = P2V(a); // physical to virtual\n  e = addr+len; // end \n  for(p = addr; p < e; p += sizeof(struct mp))\n    if(memcmp(p, \"_MP_\", 4) == 0 && sum(p, sizeof(struct mp)) == 0)\n      return (struct mp*)p;\n  return 0;\n}\n\n```","x":3040,"y":5931,"width":688,"height":463},
		{"id":"81730b7b1e2e7179","type":"text","text":"# string.c : memcmp\n```c\nint\nmemcmp(const void *v1, const void *v2, uint n)\n{\n  const uchar *s1, *s2;\n\n  s1 = v1;\n  s2 = v2;\n  while(n-- > 0){\n    if(*s1 != *s2)\n      return *s1 - *s2;\n    s1++, s2++;\n  }\n\n  return 0;\n}\n```","x":3960,"y":5577,"width":520,"height":483},
		{"id":"5b5e9cc1ef85f530","x":2740,"y":6480,"width":447,"height":268,"type":"text","text":"그럼 mp 구조체가 어디서 미리 만들어져서 저 세 위치 중 하나에 있어야 되는거 아닌가.\n\n그 부분은 어딨찌.\nSMP (multi processor system) 에서 BIOS나 펌웨어에 의해 시스템 초기화 시 생성됨.\n\n하드웨어(혹은 bios , 펌웨어) 가 생성한 정보를 찾는 과정 \n\n\n"},
		{"id":"506a529357dffce9","x":2680,"y":4610,"width":580,"height":540,"type":"text","text":"CR3 레지스터 값을 바꿀 수 있다면? \n\n커널 페이지 테이블에 접근할 수 없는 사용자 프로그램이 CR3를 조작해 사용자 공간에 커널 페이지를 매핑하면 커널 메모리를 읽을 수 있게 된다.\n\nCR3 값이 프로세스 간 공유 되거나 임의로 설정되면, 공격자는 다른 프로세스의 메모리에 접근할 수 있다\n- meltdown\n\nCR3 조작을 통해 사용자 프로세스를 커널 프로세스로 위장하거나 커널 코드를 삽입할 수 있다.\n- PTE 의 권한 비트를 조작해 읽기 전용 메모리 를 쓰기 가능으로 바꾸거나\n- 사용자 모드 메모리를 커널 코드로 위장할 수 있다\n\n\nShadow Page Table 공격\n- 정상적인 페이지 테이블을 모방해서 가짜 페이지 테이블을 생성해 정상적인 동작을 교란할 수 있다.\n\n"},
		{"id":"092abcf6ad51373c","x":3280,"y":6349,"width":522,"height":91,"type":"text","text":"반복 돌면서 범위 안에 \"\\_MP\\_\" 시그니처 있으면 mp 구조체 인것으로 파악"}
>>>>>>> Stashed changes
	],
	"edges":[
		{"id":"b0f80485378b4ac9","fromNode":"80b04e657081613f","fromSide":"right","toNode":"d3817c8333c05821","toSide":"left"},
		{"id":"6cdc2945232edab7","fromNode":"afb4acd3401de320","fromSide":"right","toNode":"d0882743ca7de9b7","toSide":"left"},
		{"id":"f6a591c0b4ca13d9","fromNode":"d0882743ca7de9b7","fromSide":"bottom","toNode":"80b04e657081613f","toSide":"top"},
		{"id":"a2ee46c1bb403de1","fromNode":"80b04e657081613f","fromSide":"left","toNode":"f8429fd3cd8338f8","toSide":"right"},
		{"id":"5993753dacc438dc","fromNode":"80b04e657081613f","fromSide":"right","toNode":"d2da0014386670b3","toSide":"left"},
		{"id":"32c622891f0187b5","fromNode":"d2da0014386670b3","fromSide":"right","toNode":"c53581449d2a4623","toSide":"left"},
		{"id":"3d40c9f1c058e1a1","fromNode":"80b04e657081613f","fromSide":"bottom","toNode":"93d2c5020b089af9","toSide":"top"},
		{"id":"2c534f3d4a82118a","fromNode":"93d2c5020b089af9","fromSide":"right","toNode":"70754fa19d2b5f1f","toSide":"left"},
		{"id":"0ddfee9ea4f3928a","fromNode":"70754fa19d2b5f1f","fromSide":"right","toNode":"19b0f1549257b44e","toSide":"left"},
		{"id":"f82514d3e39cd0e1","fromNode":"70754fa19d2b5f1f","fromSide":"right","toNode":"1af96550f66318e1","toSide":"left"},
		{"id":"84b3830bbe12588c","fromNode":"1af96550f66318e1","fromSide":"right","toNode":"3c8ae193606e7ad8","toSide":"left"},
		{"id":"0d918cd201613ce4","fromNode":"70754fa19d2b5f1f","fromSide":"right","toNode":"d4d9fd7d4bc1ac83","toSide":"left"},
		{"id":"60136d584bcb6c07","fromNode":"d4d9fd7d4bc1ac83","fromSide":"right","toNode":"bcb9689b43779a38","toSide":"left"},
		{"id":"94c094cdf9572ad2","fromNode":"93d2c5020b089af9","fromSide":"right","toNode":"be13f40570ef3608","toSide":"left"},
		{"id":"5f7f70381dbb3723","fromNode":"be13f40570ef3608","fromSide":"right","toNode":"3111d7371df2b098","toSide":"left"},
		{"id":"26a1c6342394c58d","fromNode":"93d2c5020b089af9","fromSide":"bottom","toNode":"30338f74372e9483","toSide":"top"},
		{"id":"e73c3c9c75361104","fromNode":"30338f74372e9483","fromSide":"right","toNode":"f565a77822cee056","toSide":"left"},
		{"id":"84a268e7fdf44d77","fromNode":"30338f74372e9483","fromSide":"right","toNode":"8904de52238c6c96","toSide":"left"},
		{"id":"c1e855906ba048b0","fromNode":"8904de52238c6c96","fromSide":"right","toNode":"fd49135ac1ce412b","toSide":"left"},
		{"id":"b5f4fcb9c25e60e7","fromNode":"fd49135ac1ce412b","fromSide":"right","toNode":"a9482e7dbac2ece9","toSide":"left"},
		{"id":"7d0582be2505e9b5","fromNode":"a9482e7dbac2ece9","fromSide":"right","toNode":"81730b7b1e2e7179","toSide":"left"}
	]
}